use crate::prelude::*;
use std::borrow::Cow;

const fn try_format_errno(errno: libc::c_int) -> Option<&'static str> {
    // It's okay if some of them are unreachable, as errno numbers differ across architectures
    // and are sometimes aliased.
    #![allow(unreachable_patterns)]

    // List taken from glibc, but with stuff not supported by Rust dropped.
    // IMPORTANT: Keep in sync with `arbitrary_errno`. Ideally, this would use a proc macro or
    // script, but I'm too lazy to do that for such a one-off thing that doesn't change often in
    // practice.
    match errno {
        libc::E2BIG => Some("E2BIG: Argument list too long"),
        libc::EACCES => Some("EACCES: Permission denied"),
        libc::EADDRINUSE => Some("EADDRINUSE: Address already in use"),
        libc::EADDRNOTAVAIL => Some("EADDRNOTAVAIL: Cannot assign requested address"),
        libc::EADV => Some("EADV: Advertise error"),
        libc::EAFNOSUPPORT => Some("EAFNOSUPPORT: Address family not supported by protocol"),
        libc::EAGAIN => Some("EAGAIN: Resource temporarily unavailable"),
        libc::EALREADY => Some("EALREADY: Operation already in progress"),
        libc::EBADE => Some("EBADE: Invalid exchange"),
        libc::EBADF => Some("EBADF: Bad file descriptor"),
        libc::EBADFD => Some("EBADFD: File descriptor in bad state"),
        libc::EBADMSG => Some("EBADMSG: Bad message"),
        libc::EBADR => Some("EBADR: Invalid request descriptor"),
        libc::EBADRQC => Some("EBADRQC: Invalid request code"),
        libc::EBADSLT => Some("EBADSLT: Invalid slot"),
        libc::EBFONT => Some("EBFONT: Bad font file format"),
        libc::EBUSY => Some("EBUSY: Device or resource busy"),
        libc::ECANCELED => Some("ECANCELED: Operation canceled"),
        libc::ECHILD => Some("ECHILD: No child processes"),
        libc::ECHRNG => Some("ECHRNG: Channel number out of range"),
        libc::ECOMM => Some("ECOMM: Communication error on send"),
        libc::ECONNABORTED => Some("ECONNABORTED: Software caused connection abort"),
        libc::ECONNREFUSED => Some("ECONNREFUSED: Connection refused"),
        libc::ECONNRESET => Some("ECONNRESET: Connection reset by peer"),
        libc::EDEADLK => Some("EDEADLK: Resource deadlock avoided"),
        libc::EDESTADDRREQ => Some("EDESTADDRREQ: Destination address required"),
        libc::EDOM => Some("EDOM: Numerical argument out of domain"),
        libc::EDOTDOT => Some("EDOTDOT: RFS specific error"),
        libc::EDQUOT => Some("EDQUOT: Disk quota exceeded"),
        libc::EEXIST => Some("EEXIST: File exists"),
        libc::EFAULT => Some("EFAULT: Bad address"),
        libc::EFBIG => Some("EFBIG: File too large"),
        libc::EHOSTDOWN => Some("EHOSTDOWN: Host is down"),
        libc::EHOSTUNREACH => Some("EHOSTUNREACH: No route to host"),
        libc::EHWPOISON => Some("EHWPOISON: Memory page has hardware error"),
        libc::EIDRM => Some("EIDRM: Identifier removed"),
        libc::EILSEQ => Some("EILSEQ: Invalid or incomplete multibyte or wide character"),
        libc::EINPROGRESS => Some("EINPROGRESS: Operation now in progress"),
        libc::EINTR => Some("EINTR: Interrupted system call"),
        libc::EINVAL => Some("EINVAL: Invalid argument"),
        libc::EIO => Some("EIO: Input/output error"),
        libc::EISCONN => Some("EISCONN: Transport endpoint is already connected"),
        libc::EISDIR => Some("EISDIR: Is a directory"),
        libc::EISNAM => Some("EISNAM: Is a named type file"),
        libc::EKEYEXPIRED => Some("EKEYEXPIRED: Key has expired"),
        libc::EKEYREJECTED => Some("EKEYREJECTED: Key was rejected by service"),
        libc::EKEYREVOKED => Some("EKEYREVOKED: Key has been revoked"),
        libc::EL2HLT => Some("EL2HLT: Level 2 halted"),
        libc::EL2NSYNC => Some("EL2NSYNC: Level 2 not synchronized"),
        libc::EL3HLT => Some("EL3HLT: Level 3 halted"),
        libc::EL3RST => Some("EL3RST: Level 3 reset"),
        libc::ELIBACC => Some("ELIBACC: Can not access a needed shared library"),
        libc::ELIBBAD => Some("ELIBBAD: Accessing a corrupted shared library"),
        libc::ELIBEXEC => Some("ELIBEXEC: Cannot exec a shared library directly"),
        libc::ELIBMAX => Some("ELIBMAX: Attempting to link in too many shared libraries"),
        libc::ELIBSCN => Some("ELIBSCN: .lib section in a.out corrupted"),
        libc::ELNRNG => Some("ELNRNG: Link number out of range"),
        libc::ELOOP => Some("ELOOP: Too many levels of symbolic links"),
        libc::EMEDIUMTYPE => Some("EMEDIUMTYPE: Wrong medium type"),
        libc::EMFILE => Some("EMFILE: Too many open files"),
        libc::EMLINK => Some("EMLINK: Too many links"),
        libc::EMSGSIZE => Some("EMSGSIZE: Message too long"),
        libc::EMULTIHOP => Some("EMULTIHOP: Multihop attempted"),
        libc::ENAMETOOLONG => Some("ENAMETOOLONG: File name too long"),
        libc::ENAVAIL => Some("ENAVAIL: No XENIX semaphores available"),
        libc::ENETDOWN => Some("ENETDOWN: Network is down"),
        libc::ENETRESET => Some("ENETRESET: Network dropped connection on reset"),
        libc::ENETUNREACH => Some("ENETUNREACH: Network is unreachable"),
        libc::ENFILE => Some("ENFILE: Too many open files in system"),
        libc::ENOANO => Some("ENOANO: No anode"),
        libc::ENOBUFS => Some("ENOBUFS: No buffer space available"),
        libc::ENOCSI => Some("ENOCSI: No CSI structure available"),
        libc::ENODATA => Some("ENODATA: No data available"),
        libc::ENODEV => Some("ENODEV: No such device"),
        libc::ENOENT => Some("ENOENT: No such file or directory"),
        libc::ENOEXEC => Some("ENOEXEC: Exec format error"),
        libc::ENOKEY => Some("ENOKEY: Required key not available"),
        libc::ENOLCK => Some("ENOLCK: No locks available"),
        libc::ENOLINK => Some("ENOLINK: Link has been severed"),
        libc::ENOMEDIUM => Some("ENOMEDIUM: No medium found"),
        libc::ENOMEM => Some("ENOMEM: Cannot allocate memory"),
        libc::ENOMSG => Some("ENOMSG: No message of desired type"),
        libc::ENONET => Some("ENONET: Machine is not on the network"),
        libc::ENOPKG => Some("ENOPKG: Package not installed"),
        libc::ENOPROTOOPT => Some("ENOPROTOOPT: Protocol not available"),
        libc::ENOSPC => Some("ENOSPC: No space left on device"),
        libc::ENOSR => Some("ENOSR: Out of streams resources"),
        libc::ENOSTR => Some("ENOSTR: Device not a stream"),
        libc::ENOSYS => Some("ENOSYS: Function not implemented"),
        libc::ENOTBLK => Some("ENOTBLK: Block device required"),
        libc::ENOTCONN => Some("ENOTCONN: Transport endpoint is not connected"),
        libc::ENOTDIR => Some("ENOTDIR: Not a directory"),
        libc::ENOTEMPTY => Some("ENOTEMPTY: Directory not empty"),
        libc::ENOTNAM => Some("ENOTNAM: Not a XENIX named type file"),
        libc::ENOTRECOVERABLE => Some("ENOTRECOVERABLE: State not recoverable"),
        libc::ENOTSOCK => Some("ENOTSOCK: Socket operation on non-socket"),
        libc::ENOTSUP => Some("ENOTSUP: Not supported"),
        libc::ENOTTY => Some("ENOTTY: Inappropriate ioctl for device"),
        libc::ENOTUNIQ => Some("ENOTUNIQ: Name not unique on network"),
        libc::ENXIO => Some("ENXIO: No such device or address"),
        libc::EOPNOTSUPP => Some("EOPNOTSUPP: Operation not supported"),
        libc::EOVERFLOW => Some("EOVERFLOW: Value too large for defined data type"),
        libc::EOWNERDEAD => Some("EOWNERDEAD: Owner died"),
        libc::EPERM => Some("EPERM: Operation not permitted"),
        libc::EPFNOSUPPORT => Some("EPFNOSUPPORT: Protocol family not supported"),
        libc::EPIPE => Some("EPIPE: Broken pipe"),
        libc::EPROTO => Some("EPROTO: Protocol error"),
        libc::EPROTONOSUPPORT => Some("EPROTONOSUPPORT: Protocol not supported"),
        libc::EPROTOTYPE => Some("EPROTOTYPE: Protocol wrong type for socket"),
        libc::ERANGE => Some("ERANGE: Numerical result out of range"),
        libc::EREMCHG => Some("EREMCHG: Remote address changed"),
        libc::EREMOTE => Some("EREMOTE: Object is remote"),
        libc::EREMOTEIO => Some("EREMOTEIO: Remote I/O error"),
        libc::ERESTART => Some("ERESTART: Interrupted system call should be restarted"),
        libc::ERFKILL => Some("ERFKILL: Operation not possible due to RF-kill"),
        libc::EROFS => Some("EROFS: Read-only file system"),
        libc::ESHUTDOWN => Some("ESHUTDOWN: Cannot send after transport endpoint shutdown"),
        libc::ESOCKTNOSUPPORT => Some("ESOCKTNOSUPPORT: Socket type not supported"),
        libc::ESPIPE => Some("ESPIPE: Illegal seek"),
        libc::ESRCH => Some("ESRCH: No such process"),
        libc::ESRMNT => Some("ESRMNT: Srmount error"),
        libc::ESTALE => Some("ESTALE: Stale file handle"),
        libc::ESTRPIPE => Some("ESTRPIPE: Streams pipe error"),
        libc::ETIME => Some("ETIME: Timer expired"),
        libc::ETIMEDOUT => Some("ETIMEDOUT: Connection timed out"),
        libc::ETOOMANYREFS => Some("ETOOMANYREFS: Too many references: cannot splice"),
        libc::ETXTBSY => Some("ETXTBSY: Text file busy"),
        libc::EUCLEAN => Some("EUCLEAN: Structure needs cleaning"),
        libc::EUNATCH => Some("EUNATCH: Protocol driver not attached"),
        libc::EUSERS => Some("EUSERS: Too many users"),
        libc::EWOULDBLOCK => Some("EWOULDBLOCK: Operation would block"),
        libc::EXDEV => Some("EXDEV: Invalid cross-device link"),
        libc::EXFULL => Some("EXFULL: Exchange full"),
        _ => None,
    }
}

#[cfg(test)]
static ERRNO_LIST: &[libc::c_int] = &[
    libc::EPERM,
    libc::ENOENT,
    libc::ESRCH,
    libc::EINTR,
    libc::EIO,
    libc::ENXIO,
    libc::E2BIG,
    libc::ENOEXEC,
    libc::EBADF,
    libc::ECHILD,
    libc::EDEADLK,
    libc::ENOMEM,
    libc::EACCES,
    libc::EFAULT,
    libc::ENOTBLK,
    libc::EBUSY,
    libc::EEXIST,
    libc::EXDEV,
    libc::ENODEV,
    libc::ENOTDIR,
    libc::EISDIR,
    libc::EINVAL,
    libc::EMFILE,
    libc::ENFILE,
    libc::ENOTTY,
    libc::ETXTBSY,
    libc::EFBIG,
    libc::ENOSPC,
    libc::ESPIPE,
    libc::EROFS,
    libc::EMLINK,
    libc::EPIPE,
    libc::EDOM,
    libc::ERANGE,
    libc::EAGAIN,
    libc::EINPROGRESS,
    libc::EALREADY,
    libc::ENOTSOCK,
    libc::EMSGSIZE,
    libc::EPROTOTYPE,
    libc::ENOPROTOOPT,
    libc::EPROTONOSUPPORT,
    libc::ESOCKTNOSUPPORT,
    libc::EOPNOTSUPP,
    libc::EPFNOSUPPORT,
    libc::EAFNOSUPPORT,
    libc::EADDRINUSE,
    libc::EADDRNOTAVAIL,
    libc::ENETDOWN,
    libc::ENETUNREACH,
    libc::ENETRESET,
    libc::ECONNABORTED,
    libc::ECONNRESET,
    libc::ENOBUFS,
    libc::EISCONN,
    libc::ENOTCONN,
    libc::EDESTADDRREQ,
    libc::ESHUTDOWN,
    libc::ETOOMANYREFS,
    libc::ETIMEDOUT,
    libc::ECONNREFUSED,
    libc::ELOOP,
    libc::ENAMETOOLONG,
    libc::EHOSTDOWN,
    libc::EHOSTUNREACH,
    libc::ENOTEMPTY,
    libc::EUSERS,
    libc::EDQUOT,
    libc::ESTALE,
    libc::EREMOTE,
    libc::ENOLCK,
    libc::ENOSYS,
    libc::EILSEQ,
    libc::EBADMSG,
    libc::EIDRM,
    libc::EMULTIHOP,
    libc::ENODATA,
    libc::ENOLINK,
    libc::ENOMSG,
    libc::ENOSR,
    libc::ENOSTR,
    libc::EOVERFLOW,
    libc::EPROTO,
    libc::ETIME,
    libc::ECANCELED,
    libc::EOWNERDEAD,
    libc::ENOTRECOVERABLE,
    libc::ERESTART,
    libc::ECHRNG,
    libc::EL2NSYNC,
    libc::EL3HLT,
    libc::EL3RST,
    libc::ELNRNG,
    libc::EUNATCH,
    libc::ENOCSI,
    libc::EL2HLT,
    libc::EBADE,
    libc::EBADR,
    libc::EXFULL,
    libc::ENOANO,
    libc::EBADRQC,
    libc::EBADSLT,
    libc::EBFONT,
    libc::ENONET,
    libc::ENOPKG,
    libc::EADV,
    libc::ESRMNT,
    libc::ECOMM,
    libc::EDOTDOT,
    libc::ENOTUNIQ,
    libc::EBADFD,
    libc::EREMCHG,
    libc::ELIBACC,
    libc::ELIBBAD,
    libc::ELIBSCN,
    libc::ELIBMAX,
    libc::ELIBEXEC,
    libc::ESTRPIPE,
    libc::EUCLEAN,
    libc::ENOTNAM,
    libc::ENAVAIL,
    libc::EISNAM,
    libc::EREMOTEIO,
    libc::ENOMEDIUM,
    libc::EMEDIUMTYPE,
    libc::ENOKEY,
    libc::EKEYEXPIRED,
    libc::EKEYREVOKED,
    libc::EKEYREJECTED,
    libc::ERFKILL,
    libc::EHWPOISON,
    libc::ENOTSUP,
    libc::EWOULDBLOCK,
];

#[cfg(test)]
pub fn errno_arbitrary(g: &mut Gen) -> libc::c_int {
    *g.choose(ERRNO_LIST).unwrap()
}

#[cfg(test)]
pub fn errno_shrink(code: libc::c_int) -> impl Iterator<Item = libc::c_int> {
    ERRNO_LIST.iter().copied().filter(move |c| *c < code)
}

#[cold]
#[inline(never)]
pub fn panic_errno(e: Error, syscall_name: &'static str) -> ! {
    std::panic::panic_any(normalize_errno(e, Some(syscall_name)).into_owned())
}

#[cold]
fn format_unknown_errno(errno: libc::c_int) -> String {
    let mut s = String::new();
    s.push_str("Unknown errno ");
    let mut errno = reinterpret_i32_u32(errno);
    while errno >= 10 {
        s.push(char::from_digit(errno % 10, 10).unwrap());
        errno /= 10;
    }
    s.push(char::from_digit(errno, 10).unwrap());
    s
}

pub fn normalize_errno(e: Error, syscall: Option<&'static str>) -> Cow<'static, str> {
    let result = match e.raw_os_error() {
        None => Cow::Owned(e.to_string()),
        Some(errno) => match try_format_errno(errno) {
            Some(s) => Cow::Borrowed(s),
            None => Cow::Owned(format_unknown_errno(errno)),
        },
    };

    if let Some(syscall) = syscall {
        let mut s = result.into_owned();
        s.push_str(" from syscall '");
        s.push_str(syscall);
        s.push('\'');
        Cow::Owned(s)
    } else {
        result
    }
}
